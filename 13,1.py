import numpy as np
import matplotlib.pyplot as plt

l = 1
m1 = 0
m2 = 0
N = 100
M = 100
eps = 1e-6
u0 = np.zeros(N+1)

# Определение функции правой части
def f(t,u):
    return -np.e**(-u)

# Вычисление шага сетки
h = l/N

# Определение матрицы Якоби для метода Ньютона
def Jacobi(u):
    A = np.zeros((N+1,N+1))
    for i in range(1,N):
        A[i,i-1] = 1/h**2
        A[i,i] = -2/h**2 - f(i*h,u[i])*(np.e ** (-u[i]))
        A[i,i+1] = 1/h**2
    A[0,0] = 1
    A[N,N] = 1
    return A

# Итерационный процесс метода Ньютона
for k in range(M):
    # Вычисление значения функции на сетке
    F = np.zeros(N+1)
    for i in range(1,N):
        F[i] = u0[i-1] - 2*u0[i] + u0[i+1] - h**2*f(i*h,u0[i])*(np.e ** (-u0[i]))
    F[0] = m1 - u0[0]
    F[N] = m2 - u0[N]
    # Вычисление матрицы Якоби и решение системы нелинейных уравнений
    J = Jacobi(u0)
    du = np.linalg.solve(J,-F)
    # Обновление решения
    u0 += du
    # Проверка критерия останова
    if np.linalg.norm(du) < eps:
        break

# Построение графика решения
x = np.linspace(0,l,N+1)
plt.plot(x,u0)
plt.xlabel('x')
plt.ylabel('u(x)')
plt.title('Решение уравнения d^2u/dx^2 = -exp(-u)')
plt.show()

"""

l = 1, m1 = 0, m2 = 0, N = 100, M = 100, eps = 1e-6, u0 = np.zeros(N+1): определение параметров задачи, таких как длина интервала l, значения граничных условий m1 и m2, количество узлов на сетке N, количество итераций метода Ньютона M, точность вычисления eps и начальное приближение u0, которое инициализируется нулями.
def f(t,u): return -np.e**(-u): определение функции правой части дифференциального уравнения f(t,u) = -e^(-u).
h = l/N: вычисление шага сетки.
def Jacobi(u): ...: определение функции Jacobi, которая вычисляет матрицу Якоби для метода Ньютона.
for k in range(M):: цикл по количеству итераций метода Ньютона.
F = np.zeros(N+1): инициализация массива F нулями.
for i in range(1,N): ...: цикл по узлам на сетке для вычисления значений функции F на сетке.
F[0] = m1 - u0[0], F[N] = m2 - u0[N]: задание граничных условий.
J = Jacobi(u0): вычисление матрицы Якоби для текущего значения u0.
du = np.linalg.solve(J,-F): решение системы нелинейных уравнений методом Гаусса-Зейделя.
u0 += du: обновление значения u0 на основе найденного решения du.
if np.linalg.norm(du) < eps: break: проверка критерия останова: если норма разности между текущим и предыдущим значениями u0 становится меньше заданной точности eps, то выход из цикла.
x = np.linspace(0,l,N+1): вычисление массива x с координатами узлов на сетке.

"""